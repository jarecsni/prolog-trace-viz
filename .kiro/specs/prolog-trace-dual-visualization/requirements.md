# Requirements Document

## Introduction

This document specifies requirements for a major rework of the Prolog trace visualization system. The tool generates educational visualizations from Prolog execution traces using a dual-format approach: a detailed execution timeline for step-by-step understanding, and a structural call tree for overview. The visualization must be rock-solid, relying only on data directly captured from Prolog's tracer hooks without heuristics.

## Glossary

- **Prolog**: A logic programming language based on formal logic
- **Query**: A question posed to a Prolog program (e.g., `t(0+1+1, B)`)
- **Goal**: A predicate that Prolog attempts to prove or solve
- **Clause**: A Prolog rule or fact that can match a goal
- **Unification**: The process of matching a goal with a clause head and binding variables
- **Port**: A trace event type (call, exit, redo, fail) from Prolog's 4-port model
- **Internal Variable**: Runtime variable names like `_8822` generated by Prolog
- **Tracer Hook**: SWI-Prolog's `prolog_trace_interception/4` mechanism for capturing execution events
- **Execution Timeline**: A flat, sequential list of execution steps showing CALL/EXIT/REDO/FAIL events
- **Call Tree**: A hierarchical diagram showing the structure of goal calls and subgoals
- **Stack Level**: The depth of the call stack during execution

## Requirements

### Requirement 1: Command-Line Interface

**User Story:** As a user, I want a simple command-line interface, so that I can quickly generate trace visualizations.

#### Acceptance Criteria

1. WHEN the user invokes the tool with a Prolog file and query THEN the system SHALL generate a trace visualization
2. WHEN the user provides invalid arguments THEN the system SHALL display helpful error messages
3. WHEN the user invokes with `--help` or `-h` THEN the system SHALL display usage documentation
4. WHEN the user invokes with `--version` or `-v` THEN the system SHALL display the tool version
5. WHEN the user specifies `--output` or `-o` with a file path THEN the system SHALL write output to that file
6. WHEN no output file is specified THEN the system SHALL write to stdout
7. WHEN the user specifies `--depth N` THEN the system SHALL limit tracing to depth N
8. WHEN no depth is specified THEN the system SHALL use default depth of 100
9. WHEN the user specifies `--verbose` THEN the system SHALL display detailed processing information
10. WHEN the user specifies `--quiet` THEN the system SHALL suppress all non-error output
11. WHEN required arguments are missing THEN the system SHALL display usage and exit with non-zero status

### Requirement 18: Dual Visualization Format

**User Story:** As a Prolog student, I want to see both a step-by-step timeline and a structural overview, so that I can understand both the execution order and the call structure.

#### Acceptance Criteria

1. WHEN the tool generates output THEN the system SHALL produce both an execution timeline and a call tree diagram
2. WHEN displaying the timeline THEN the system SHALL show events in sequential execution order with step numbers
3. WHEN displaying the call tree THEN the system SHALL show the hierarchical structure of goal calls
4. WHEN cross-referencing between formats THEN the system SHALL use consistent step numbering in both timeline and tree
5. WHEN a student reads the timeline THEN the system SHALL show CALL, EXIT, REDO, and FAIL events clearly
6. WHEN a student views the tree THEN the system SHALL show parent-child relationships between goals
7. WHEN the query has multiple solutions THEN the system SHALL show the first solution only
8. WHEN the original query is provided THEN the system SHALL preserve it for display purposes

### Requirement 18: Execution Timeline Generation

**User Story:** As a Prolog student, I want a flat, numbered timeline of execution events, so that I can follow exactly what Prolog does step by step.

#### Acceptance Criteria

1. WHEN generating the timeline THEN the system SHALL create a numbered list of execution steps
2. WHEN a CALL event occurs THEN the system SHALL show the goal being called, the clause matched, unifications, and spawned subgoals
3. WHEN an EXIT event occurs THEN the system SHALL show the goal succeeded, final bindings, and which step it returns to
4. WHEN a REDO event occurs THEN the system SHALL show backtracking is happening
5. WHEN a FAIL event occurs THEN the system SHALL show the goal failed and backtracking occurs
6. WHEN displaying steps THEN the system SHALL use clear visual formatting with boxes or indentation
7. WHEN showing clause matches THEN the system SHALL include the clause head, body, and line number
8. WHEN showing unifications THEN the system SHALL display variable bindings extracted from the trace
9. WHEN a goal spawns subgoals THEN the system SHALL list the subgoals that will be solved
10. WHEN an EXIT returns THEN the system SHALL reference which CALL step it corresponds to

### Requirement 18: Call Tree Diagram Generation

**User Story:** As a Prolog student, I want a tree diagram showing the call structure, so that I can see the big picture of how goals relate.

#### Acceptance Criteria

1. WHEN generating the tree THEN the system SHALL create a Mermaid graph diagram
2. WHEN showing nodes THEN the system SHALL include the goal, clause number, and final binding
3. WHEN showing edges THEN the system SHALL use arrows to indicate "spawns subgoal" relationships
4. WHEN labelling nodes THEN the system SHALL include both CALL step number and EXIT step number
5. WHEN a goal succeeds THEN the system SHALL use green styling for the node
6. WHEN a goal fails THEN the system SHALL use red styling for the node
7. WHEN showing the root query THEN the system SHALL use blue styling
8. WHEN the tree is rendered THEN the system SHALL be compact and readable

### Requirement 18: Reliable Unification Extraction

**User Story:** As a developer, I want unifications extracted reliably from trace data, so that the visualization is accurate without heuristics.

#### Acceptance Criteria

1. WHEN extracting unifications THEN the system SHALL compare CALL goal against EXIT goal to find bindings
2. WHEN a variable appears in CALL goal THEN the system SHALL identify its bound value in EXIT goal
3. WHEN comparing goals THEN the system SHALL use structural term matching
4. WHEN displaying unifications THEN the system SHALL show internal variables as-is (e.g., `_8822 = 1+0`)
5. WHEN matching clause head to goal THEN the system SHALL extract pattern match bindings (e.g., `X = 0`)
6. WHEN no unifications exist THEN the system SHALL not display an empty unifications section
7. WHEN unifications are complex THEN the system SHALL handle nested structures correctly

### Requirement 18: Clause Information Display

**User Story:** As a Prolog student, I want to see which clause matched each goal, so that I can understand why Prolog made each choice.

#### Acceptance Criteria

1. WHEN a goal matches a clause THEN the system SHALL display the clause head
2. WHEN displaying a clause THEN the system SHALL include the line number from the source file
3. WHEN multiple clauses exist on the same line THEN the system SHALL use dot notation (e.g., 26.1, 26.2, 26.3)
4. WHEN a clause has a body THEN the system SHALL display the body goals
5. WHEN a clause is a fact THEN the system SHALL indicate it has no body
6. WHEN showing clause info THEN the system SHALL use data from the tracer's clause field
7. WHEN the tracer provides clause info THEN the system SHALL use it directly without heuristics
8. WHEN displaying clauses THEN the system SHALL format them readably with proper spacing

### Requirement 18: Subgoal Tracking

**User Story:** As a Prolog student, I want to see what subgoals are spawned by each clause, so that I understand how execution proceeds.

#### Acceptance Criteria

1. WHEN a clause has a body THEN the system SHALL extract the subgoals from the body
2. WHEN displaying a CALL step THEN the system SHALL list the subgoals that will be solved with labels (e.g., [1.1], [1.2])
3. WHEN subgoals are listed THEN the system SHALL show them in the order they will be executed
4. WHEN a subgoal is solved THEN the system SHALL show it as a separate step in the timeline with a marker indicating which subgoal it is
5. WHEN variables are shared between subgoals THEN the system SHALL show the same variable name
6. WHEN a subgoal completes THEN the system SHALL show how its bindings affect subsequent subgoals
7. WHEN displaying body goals after substitution THEN the system SHALL show clause variables (e.g., `X1`) consistently
8. WHEN a clause body is `t(X+1, X1), t(X1+1, Z)` THEN the system SHALL show that `X1` connects both subgoals
9. WHEN labelling subgoals THEN the system SHALL use format [StepNumber.SubgoalIndex] (e.g., [1.1], [1.2])
10. WHEN a CALL step solves a subgoal THEN the system SHALL display "◀── Solving subgoal [X.Y]"
11. WHEN an EXIT step completes a subgoal THEN the system SHALL display "◀── Completed subgoal [X.Y]"
12. WHEN an EXIT step completes THEN the system SHALL indicate which subgoal comes next (if any)

### Requirement 18: Step Numbering and Cross-Referencing

**User Story:** As a Prolog student, I want consistent step numbers across both visualizations, so that I can easily cross-reference between them.

#### Acceptance Criteria

1. WHEN numbering steps THEN the system SHALL assign sequential numbers starting from 1
2. WHEN a CALL event occurs THEN the system SHALL assign it a step number
3. WHEN an EXIT event occurs THEN the system SHALL assign it a step number
4. WHEN showing the timeline THEN the system SHALL display step numbers prominently
5. WHEN showing the tree THEN the system SHALL include CALL step number on each node
6. WHEN showing the tree THEN the system SHALL include EXIT step number on each node
7. WHEN an EXIT occurs THEN the system SHALL reference which CALL step it returns to
8. WHEN using circled numbers THEN the system SHALL use Unicode characters (①②③) for visual clarity

### Requirement 18: Backtracking Visualization

**User Story:** As a Prolog student, I want to see backtracking clearly, so that I understand how Prolog explores alternatives.

#### Acceptance Criteria

1. WHEN a REDO event occurs THEN the system SHALL show backtracking is happening
2. WHEN a FAIL event occurs THEN the system SHALL show the goal failed
3. WHEN showing backtracking THEN the system SHALL indicate which step is being reconsidered
4. WHEN multiple clauses are tried THEN the system SHALL show each attempt as separate steps
5. WHEN a goal fails THEN the system SHALL show which parent goal receives the failure
6. WHEN displaying failed attempts in the tree THEN the system SHALL use red styling
7. WHEN displaying successful paths in the tree THEN the system SHALL use green styling

### Requirement 18: Variable Flow Between Subgoals

**User Story:** As a Prolog student, I want to see how variables flow between subgoals, so that I understand data dependencies.

#### Acceptance Criteria

1. WHEN a subgoal binds a variable THEN the system SHALL show the binding in the EXIT step
2. WHEN a subsequent subgoal uses that variable THEN the system SHALL show the substituted value
3. WHEN displaying subgoal calls THEN the system SHALL show variables with their current bindings
4. WHEN a variable is shared THEN the system SHALL use consistent naming across subgoals
5. WHEN showing variable flow THEN the system SHALL add notes indicating where values came from
6. WHEN a clause body contains variables like `X1` THEN the system SHALL show them consistently across subgoals
7. WHEN displaying the next subgoal after a binding THEN the system SHALL show which variable was substituted

### Requirement 18: Single Detail Level

**User Story:** As a user, I want one good standard visualization level, so that I don't have to choose between confusing options.

#### Acceptance Criteria

1. WHEN generating output THEN the system SHALL use a single standard detail level
2. WHEN the standard level is used THEN the system SHALL show all essential information for learning
3. WHEN the standard level is used THEN the system SHALL hide unnecessary implementation details
4. WHEN built-in predicates are called THEN the system SHALL show them but keep them concise
5. WHEN the CLI is invoked THEN the system SHALL not offer detail level options
6. WHEN the code is structured THEN the system SHALL remove detail level parameters and conditionals

### Requirement 18: Tracer Data Usage

**User Story:** As a developer, I want the visualization to use only tracer-provided data, so that it's reliable and maintainable.

#### Acceptance Criteria

1. WHEN building visualizations THEN the system SHALL use only data from trace events
2. WHEN trace events provide clause info THEN the system SHALL use it directly
3. WHEN extracting unifications THEN the system SHALL compare CALL and EXIT goals structurally
4. WHEN determining execution order THEN the system SHALL use the event sequence from the tracer
5. WHEN identifying subgoals THEN the system SHALL parse them from the clause body field
6. WHEN the system needs information THEN the system SHALL not use heuristics or guessing
7. WHEN tracer data is missing THEN the system SHALL omit that information rather than guess

### Requirement 18: Output Format

**User Story:** As a Prolog student, I want a well-formatted markdown document, so that I can read it easily in my editor or browser.

#### Acceptance Criteria

1. WHEN generating output THEN the system SHALL create a markdown document
2. WHEN the document is created THEN the system SHALL include a title with the query
3. WHEN the document is created THEN the system SHALL include the original query in a code block
4. WHEN the document is created THEN the system SHALL include a table of clause definitions
5. WHEN the document is created THEN the system SHALL include the execution timeline section
6. WHEN the document is created THEN the system SHALL include the call tree diagram section
7. WHEN the document is created THEN the system SHALL include the final answer
8. WHEN formatting code THEN the system SHALL use plain code blocks without syntax highlighting
9. WHEN showing Prolog queries THEN the system SHALL not include the `?-` prompt

### Requirement 18: Error Handling

**User Story:** As a user, I want clear error messages when something goes wrong, so that I can fix issues quickly.

#### Acceptance Criteria

1. WHEN the Prolog file does not exist THEN the system SHALL report a file not found error
2. WHEN SWI-Prolog is not installed THEN the system SHALL report that SWI-Prolog is required
3. WHEN the query syntax is invalid THEN the system SHALL report the syntax error from Prolog
4. WHEN trace parsing fails THEN the system SHALL report the parsing error with context
5. WHEN file writing fails THEN the system SHALL report the I/O error with details
6. WHEN the tracer produces no events THEN the system SHALL report that no trace was captured

### Requirement 18: Performance

**User Story:** As a user, I want the tool to handle large traces efficiently, so that I can visualize complex programs.

#### Acceptance Criteria

1. WHEN processing large traces THEN the system SHALL complete in reasonable time
2. WHEN building the timeline THEN the system SHALL use efficient data structures
3. WHEN building the tree THEN the system SHALL avoid redundant processing
4. WHEN formatting output THEN the system SHALL stream to file rather than building in memory
5. WHEN the trace has deep recursion THEN the system SHALL handle it without stack overflow
6. WHEN no depth limit is specified THEN the system SHALL use a default maximum depth of 100
7. WHEN the user specifies a depth limit THEN the system SHALL stop tracing at that depth
8. WHEN the depth limit is reached THEN the system SHALL indicate truncation in the output

### Requirement 18: Complex Unification Handling

**User Story:** As a Prolog student, I want complex unifications displayed clearly, so that I can understand structural matching.

#### Acceptance Criteria

1. WHEN unifying lists THEN the system SHALL show list structure clearly (e.g., `[H|T] = [1,2,3]`)
2. WHEN unifying compound terms THEN the system SHALL show the full structure
3. WHEN unifying arithmetic expressions THEN the system SHALL preserve operator structure (e.g., `X+1+1`)
4. WHEN displaying complex unifications THEN the system SHALL use proper formatting for readability
5. WHEN a unification involves nested structures THEN the system SHALL show the complete binding

### Requirement 18: Built-in Predicate Handling

**User Story:** As a Prolog student, I want built-in predicates shown concisely, so that they don't clutter the visualization.

#### Acceptance Criteria

1. WHEN a built-in predicate is called THEN the system SHALL show it in the timeline
2. WHEN displaying built-in predicates THEN the system SHALL keep the format concise
3. WHEN built-ins like `true` are called THEN the system SHALL show them but minimize visual noise
4. WHEN arithmetic predicates like `is` or `>` are called THEN the system SHALL show the evaluation
5. WHEN the tree includes built-ins THEN the system SHALL include them in the structure

### Requirement 18: Cut Behaviour Visualization

**User Story:** As a Prolog student, I want to understand cut behaviour, so that I can see why backtracking was prevented.

#### Acceptance Criteria

1. WHEN a cut is executed THEN the system SHALL show it in the timeline
2. WHEN cut prevents backtracking THEN the system SHALL indicate why no alternatives were tried
3. WHEN displaying cut in the tree THEN the system SHALL show it as part of the clause body
4. WHEN cut removes choice points THEN the system SHALL note this in the visualization
